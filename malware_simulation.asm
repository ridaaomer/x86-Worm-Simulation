.386
.model flat, stdcall
option casemap:none

ExitProcess PROTO STDCALL :DWORD
Sleep PROTO STDCALL :DWORD
GetStdHandle PROTO STDCALL :DWORD
WriteConsoleA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
GetTickCount PROTO STDCALL
ReadConsoleA PROTO STDCALL :DWORD,:DWORD,:DWORD,:DWORD,:DWORD
wsprintfA PROTO C :VARARG
SetConsoleTextAttribute PROTO STDCALL :DWORD,:DWORD

STD_OUTPUT_HANDLE equ -11
STD_INPUT_HANDLE equ -10

includelib kernel32.lib
includelib user32.lib

.data
    hStdOut dd 0
    hStdIn dd 0
    bytesWritten dd 0
    bytesRead dd 0
    
    userChoice db 0
    inputBuffer db 16 dup(0)
    outputBuffer db 256 dup(0)
    randSeed dd 0               ; NEW: Seed for random generator
    
    ; Menu messages
    msg_title db '=== MALWARE SIMULATION ENGINE ===', 13, 10
              db 'Select simulation type:', 13, 10, 13, 10, 0
    
    msg_menu db '1. Basic Worm (Sequential)', 13, 10
             db '2. Fast Worm (Exponential)', 13, 10
             db '3. Stealth Malware', 13, 10
             db '4. Random Chaos', 13, 10      ; NEW OPTION
             db '0. Exit', 13, 10, 13, 10
             db 'Choice: ', 0
    
    msg_invalid db 'Invalid! Press Enter...', 13, 10, 0
    msg_continue db 13, 10, 'Press Enter...', 0
    
    ; Status messages
    msg_infecting db '[INFECT] Block %d', 13, 10, 0
    msg_executing db '[EXECUTE] Block %d', 13, 10, 0
    msg_spreading db '[SPREAD] %d infected', 13, 10, 0
    msg_scanning  db '[SCAN] Probing random block...', 13, 10, 0 ; NEW MSG
    
    ; Memory display
    msg_memory db 'Memory: ', 0
    msg_clean db '_ ', 0
    msg_infected db '# ', 0
    msg_executing_visual db '! ', 0
    
    ; Statistics
    msg_stats db 13, 10, '=== STATS ===', 13, 10
              db 'Total: %d', 13, 10
              db 'Infected: %d', 13, 10
              db 'Rate: %d%%', 13, 10
              db 'Cycles: %d', 13, 10
              db 'Time: %d ms', 13, 10, 0
    
    newline db 13, 10, 0

    ; Option Titles
    worm_title db ' [BASIC WORM] Sequential spread', 13, 10, 0
    fast_title db ' [FAST WORM] Exponential spread', 13, 10, 0
    stealth_title db ' [STEALTH] Infecting every 2nd block', 13, 10, 0
    random_title db ' [CHAOS] Random memory scanning', 13, 10, 0

.code

; Simple console color
SetConsoleColor proc color:dword
    pushad              ; Save ALL registers
    push color
    push hStdOut
    call SetConsoleTextAttribute
    popad               ; Restore ALL registers
    ret
SetConsoleColor endp

; Print string
PrintString proc stringPtr:dword
    pushad              ; Save ALL registers
    mov esi, stringPtr
    mov ecx, 0
count_loop:
    cmp byte ptr [esi], 0
    je done_count
    inc esi
    inc ecx
    jmp count_loop
done_count:
    push 0
    push offset bytesWritten
    push ecx
    push stringPtr
    push hStdOut
    call WriteConsoleA
    popad               ; Restore registers
    ret
PrintString endp

; Print formatted text
PrintFormatted proc fmtPtr:dword, value:dword
    pushad              ; Save ALL registers
    push value
    push fmtPtr
    push offset outputBuffer
    call wsprintfA      
    add esp, 12
    
    ; Calculate length
    mov esi, offset outputBuffer
    mov ecx, 0
count_fmt:
    cmp byte ptr [esi], 0
    je done_fmt
    inc esi
    inc ecx
    jmp count_fmt
done_fmt:
    push 0
    push offset bytesWritten
    push ecx
    push offset outputBuffer
    push hStdOut
    call WriteConsoleA
    popad               ; Restore registers
    ret
PrintFormatted endp

; Get user choice
GetUserChoice proc
    push 0
    push offset bytesRead
    push 16
    push offset inputBuffer
    push hStdIn
    call ReadConsoleA
    
    mov al, inputBuffer
    sub al, '0'
    mov userChoice, al
    ret
GetUserChoice endp

; Wait for Enter
WaitForEnter proc
    push offset msg_continue
    call PrintString
    
    push 0
    push offset bytesRead
    push 16
    push offset inputBuffer
    push hStdIn
    call ReadConsoleA
    ret
WaitForEnter endp

; =======================================================================
; OPTION 1: BASIC WORM
; =======================================================================
Option1 proc
    mov ecx, 16
    sub esp, ecx        
    mov esi, esp        
    
    xor ecx, ecx
    mov ebx, 0          
    mov edi, 0          
    
clear1:
    mov byte ptr [esi + ecx], 0
    inc ecx
    cmp ecx, 16
    jl clear1
    
    call GetTickCount
    push eax            
    
    push 12
    call SetConsoleColor
    push offset worm_title
    call PrintString
    push 7
    call SetConsoleColor
    
    xor ecx, ecx        
    
worm_loop:
    cmp ecx, 16
    jge worm_done
    
    cmp byte ptr [esi + ecx], 0
    jne skip_worm
    
    mov byte ptr [esi + ecx], 1
    inc ebx
    
    mov byte ptr [esi + ecx], 2
    
    push ecx
    push offset msg_executing
    call PrintFormatted
    
    pushad              
    push 7
    call SetConsoleColor
    push offset msg_memory
    call PrintString
    
    xor edx, edx        
show_mem1:
    cmp edx, 16
    jge show_done1
    
    mov al, [esi + edx]
    cmp al, 0
    je show_c1
    cmp al, 1
    je show_i1
    
    push 14
    call SetConsoleColor
    push offset msg_executing_visual
    call PrintString    
    jmp next1
    
show_c1:
    push 7
    call SetConsoleColor
    push offset msg_clean
    call PrintString
    jmp next1
    
show_i1:
    push 12
    call SetConsoleColor
    push offset msg_infected
    call PrintString
    
next1:
    inc edx
    jmp show_mem1
    
show_done1:
    push offset newline
    call PrintString
    push 7
    call SetConsoleColor
    popad               
    
    push ecx
    push 100
    call Sleep
    pop ecx             
    
    mov byte ptr [esi + ecx], 1
    
skip_worm:
    inc ecx
    inc edi
    
    push ebx
    push offset msg_spreading
    call PrintFormatted
    
    push ecx
    push 50
    call Sleep
    pop ecx
    
    jmp worm_loop
    
worm_done:
    call GetTickCount
    pop edx             
    sub eax, edx
    push eax            
    
    mov eax, ebx
    imul eax, 100
    xor edx, edx
    mov ecx, 16
    div ecx
    
    pop ecx             
    push ecx
    push edi            
    push eax            
    push ebx            
    push 16             
    push offset msg_stats
    push offset outputBuffer
    call wsprintfA
    add esp, 28
    
    push offset outputBuffer
    call PrintString
    
    add esp, 16         
    ret
Option1 endp

; =======================================================================
; OPTION 2: FAST WORM
; =======================================================================
Option2 proc
    mov ecx, 16
    sub esp, ecx
    mov esi, esp
    
    xor ecx, ecx
    mov ebx, 0
    mov edi, 0
    
clear2:
    mov byte ptr [esi + ecx], 0
    inc ecx
    cmp ecx, 16
    jl clear2
    
    call GetTickCount
    push eax
    
    push 12
    call SetConsoleColor
    push offset fast_title
    call PrintString
    push 7
    call SetConsoleColor
    
    mov byte ptr [esi + 0], 1
    inc ebx
    
    push 0
    push offset msg_infecting
    call PrintFormatted
    
    push 100
    call Sleep
    
fast_main:
    mov edx, 0          
    xor ecx, ecx        
    
scan_fast:
    cmp ecx, 16
    jge scan_done
    
    cmp byte ptr [esi + ecx], 1
    jne next_fast
    
    mov eax, ecx
    dec eax
    cmp eax, 0
    jl try_right_fast
    
    cmp byte ptr [esi + eax], 0
    jne try_right_fast
    
    mov byte ptr [esi + eax], 1
    inc ebx
    push eax
    push offset msg_infecting
    call PrintFormatted
    mov edx, 1
    
try_right_fast:
    mov eax, ecx
    inc eax
    cmp eax, 16
    jge execute_fast
    
    cmp byte ptr [esi + eax], 0
    jne execute_fast
    
    mov byte ptr [esi + eax], 1
    inc ebx
    push eax
    push offset msg_infecting
    call PrintFormatted
    mov edx, 1
    
execute_fast:
    mov byte ptr [esi + ecx], 2
    push ecx
    push offset msg_executing
    call PrintFormatted
    
    pushad
    push 7
    call SetConsoleColor
    push offset msg_memory
    call PrintString
    
    xor eax, eax
show_fast:
    cmp eax, 16
    jge show_fast_done
    
    mov cl, [esi + eax]
    cmp cl, 0
    je show_cf
    cmp cl, 1
    je show_if
    
    push 14
    call SetConsoleColor
    push offset msg_executing_visual
    call PrintString
    jmp next_fast_show
    
show_cf:
    push 7
    call SetConsoleColor
    push offset msg_clean
    call PrintString
    jmp next_fast_show
    
show_if:
    push 12
    call SetConsoleColor
    push offset msg_infected
    call PrintString
    
next_fast_show:
    inc eax
    jmp show_fast
    
show_fast_done:
    push offset newline
    call PrintString
    push 7
    call SetConsoleColor
    popad
    
    push ecx
    push 80
    call Sleep
    pop ecx
    
    mov byte ptr [esi + ecx], 1
    inc edi
    
next_fast:
    inc ecx
    jmp scan_fast
    
scan_done:
    cmp ebx, 16
    jge fast_done
    cmp edx, 0
    je fast_done
    
    push 30
    call Sleep
    jmp fast_main
    
fast_done:
    call GetTickCount
    pop edx
    sub eax, edx
    push eax
    
    mov eax, ebx
    imul eax, 100
    xor edx, edx
    mov ecx, 16
    div ecx
    
    pop ecx
    push ecx
    push edi
    push eax
    push ebx
    push 16
    push offset msg_stats
    push offset outputBuffer
    call wsprintfA
    add esp, 28
    
    push offset outputBuffer
    call PrintString
    
    add esp, 16
    ret
Option2 endp

; =======================================================================
; OPTION 3: STEALTH MALWARE
; =======================================================================
Option3 proc
    mov ecx, 16
    sub esp, ecx
    mov esi, esp
    
    xor ecx, ecx
    mov ebx, 0          
    mov edi, 0          
    
clear3:
    mov byte ptr [esi + ecx], 0
    inc ecx
    cmp ecx, 16
    jl clear3
    
    call GetTickCount
    push eax
    
    push 10
    call SetConsoleColor
    push offset stealth_title
    call PrintString
    push 7
    call SetConsoleColor
    
    xor ecx, ecx        
    
stealth_loop:
    cmp ecx, 16
    jge stealth_done
    
    test ecx, 1
    jnz stealth_next
    
    cmp byte ptr [esi + ecx], 0
    jne stealth_next
    
    mov byte ptr [esi + ecx], 1
    inc ebx
    
    push ecx
    push offset msg_infecting
    call PrintFormatted
    
    mov byte ptr [esi + ecx], 2
    
    pushad
    push 7
    call SetConsoleColor
    push offset msg_memory
    call PrintString
    
    xor edx, edx
show_stealth:
    cmp edx, 16
    jge show_stealth_done
    
    mov al, [esi + edx]
    cmp al, 0
    je show_cs
    cmp al, 1
    je show_is
    
    push 14
    call SetConsoleColor
    push offset msg_executing_visual
    call PrintString
    jmp next_s
    
show_cs:
    push 7
    call SetConsoleColor
    push offset msg_clean
    call PrintString
    jmp next_s
    
show_is:
    push 12
    call SetConsoleColor
    push offset msg_infected
    call PrintString
    
next_s:
    inc edx
    jmp show_stealth
    
show_stealth_done:
    push offset newline
    call PrintString
    push 7
    call SetConsoleColor
    popad
    
    push ecx
    push 150
    call Sleep
    pop ecx
    
    mov byte ptr [esi + ecx], 1
    inc edi
    
stealth_next:
    inc ecx
    push ecx
    push 100
    call Sleep
    pop ecx
    jmp stealth_loop
    
stealth_done:
    call GetTickCount
    pop edx
    sub eax, edx
    push eax
    
    mov eax, ebx
    imul eax, 100
    xor edx, edx
    mov ecx, 16
    div ecx
    
    pop ecx
    push ecx
    push edi
    push eax
    push ebx
    push 16
    push offset msg_stats
    push offset outputBuffer
    call wsprintfA
    add esp, 28
    
    push offset outputBuffer
    call PrintString
    
    add esp, 16
    ret
Option3 endp

; =======================================================================
; OPTION 4: RANDOM CHAOS (NEW)
; =======================================================================
Option4 proc
    mov ecx, 16
    sub esp, ecx
    mov esi, esp
    
    ; Clear Memory
    xor ecx, ecx
    mov ebx, 0          ; total infected
    mov edi, 0          ; cycles
    
clear4:
    mov byte ptr [esi + ecx], 0
    inc ecx
    cmp ecx, 16
    jl clear4
    
    ; Initial Seed from time
    call GetTickCount
    mov randSeed, eax
    push eax            ; Save start time
    
    push 13             ; Light Magenta
    call SetConsoleColor
    push offset random_title
    call PrintString
    push 7
    call SetConsoleColor
    
random_loop:
    ; Check if all infected
    cmp ebx, 16
    jge random_done
    
    ; --- Generate Random Number (Linear Congruential Generator) ---
    call GetTickCount   ; Use Time to add entropy
    add eax, randSeed   ; Mix with previous seed
    imul eax, 1103515245
    add eax, 12345
    mov randSeed, eax   ; Save new seed
    
    and eax, 0Fh        ; Limit to 0-15
    mov ecx, eax        ; ECX = Target Index
    ; --------------------------------------------------------------
    
    ; Check if clean
    cmp byte ptr [esi + ecx], 0
    jne random_miss     ; If infected, skip (collision)
    
    ; HIT: Infect it
    mov byte ptr [esi + ecx], 1
    inc ebx
    inc edi             ; Count as effective cycle
    
    push ecx
    push offset msg_infecting
    call PrintFormatted
    
    ; Execute visual
    mov byte ptr [esi + ecx], 2
    
    ; Show Memory
    pushad
    push 7
    call SetConsoleColor
    push offset msg_memory
    call PrintString
    
    xor edx, edx
show_rand:
    cmp edx, 16
    jge show_rand_done
    
    mov al, [esi + edx]
    cmp al, 0
    je show_cr
    cmp al, 1
    je show_ir
    
    push 14
    call SetConsoleColor
    push offset msg_executing_visual
    call PrintString
    jmp next_r
    
show_cr:
    push 7
    call SetConsoleColor
    push offset msg_clean
    call PrintString
    jmp next_r
    
show_ir:
    push 12
    call SetConsoleColor
    push offset msg_infected
    call PrintString
    
next_r:
    inc edx
    jmp show_rand
    
show_rand_done:
    push offset newline
    call PrintString
    push 7
    call SetConsoleColor
    popad
    
    ; Reset block to 'infected' state (1)
    mov byte ptr [esi + ecx], 1
    
    push 100            ; Slower sleep for hits
    call Sleep
    
    jmp random_loop
    
random_miss:
    ; Missed (collision) - Just sleep briefly to show scanning effort
    push 10             ; Fast sleep for misses
    call Sleep
    jmp random_loop
    
random_done:
    call GetTickCount
    pop edx
    sub eax, edx
    push eax
    
    mov eax, ebx
    imul eax, 100
    xor edx, edx
    mov ecx, 16
    div ecx
    
    pop ecx
    push ecx
    push edi
    push eax
    push ebx
    push 16
    push offset msg_stats
    push offset outputBuffer
    call wsprintfA
    add esp, 28
    
    push offset outputBuffer
    call PrintString
    
    add esp, 16
    ret
Option4 endp

; =======================================================================
; MAIN
; =======================================================================
main proc
    push STD_OUTPUT_HANDLE
    call GetStdHandle
    mov hStdOut, eax
    
    push STD_INPUT_HANDLE
    call GetStdHandle
    mov hStdIn, eax
    
menu:
    push offset newline
    call PrintString
    push offset newline
    call PrintString
    
    push 14
    call SetConsoleColor
    push offset msg_title
    call PrintString
    push 7
    call SetConsoleColor
    
    push offset msg_menu
    call PrintString
    
    call GetUserChoice
    
    cmp userChoice, 0
    jl invalid
    cmp userChoice, 4       ; UPDATED: Allow choice 4
    jg invalid
    
    cmp userChoice, 0
    je exit_program
    
    cmp userChoice, 1
    je run1
    cmp userChoice, 2
    je run2
    cmp userChoice, 3
    je run3
    cmp userChoice, 4       ; UPDATED: Jump to run4
    je run4
    
run1:
    call Option1
    jmp done
    
run2:
    call Option2
    jmp done
    
run3:
    call Option3
    jmp done

run4:
    call Option4
    jmp done
    
done:
    call WaitForEnter
    jmp menu
    
invalid:
    push 12
    call SetConsoleColor
    push offset msg_invalid
    call PrintString
    push 7
    call SetConsoleColor
    call WaitForEnter
    jmp menu
    
exit_program:
    push 0
    call ExitProcess
main endp

end main